"""
Top Down
- scan in all playlists - set fields for scanning in tracks
- manage db playlists - db
- scan in all tracks
- scan genres and update trcak genres
- remove uneeded personal playlists
- concurrent, metadata, aysnc, pi
- radios - unfollow and control via db
- reduce - radios
"""
from spotipy import Spotify
from spotipy.oauth2 import SpotifyClientCredentials, SpotifyOAuth
from spotipy.exceptions import SpotifyException

from _constants import *
from _db import *

from collections.abc import Sequence
from concurrent.futures import ThreadPoolExecutor, as_completed
from dotenv import load_dotenv
from json import dump, dumps, load
from math import ceil
from os import getenv, system
from time import sleep

import typing

def concurrently(func, args: Sequence, max_workers: int = 5) -> typing.List:
   with ThreadPoolExecutor(max_workers=max_workers) as executor:
      future_to_args = {executor.submit(func, arg): arg for arg in args}
      results = []
      for future in as_completed(future_to_args):
         arg = future_to_args[future]
         try:
            result = future.result()
         except Exception as exc:
            print('%r generated an exception: %s' % (arg, exc))
         else:
            results.append(result)
   return results

def syncPlaylistDescriptionToDB():
   print('TODO syncPlaylistDescriptionToDB')
   return

def syncPlaylistDescriptionFromDB():
   print('TODO syncPlaylistDescriptionToDB')
   return

##########
#  MAIN  #
##########
if __name__ == '__main__':
   load_dotenv()
   usr  = getenv('usr')
   auth = SpotifyOAuth(scope=SCOPE)#,open_browser=False, cache_path="./.cache.json")
   sp   = Spotify(auth_manager=auth)
   jprint = lambda obj: print(dumps(obj, indent=2))

   # test spotify connection
   active_device = None
   devices = sp.devices() #! timeout
   if devices:
      active_device = [d for d in devices if d['is_active']]
      if active_device:
         active_device = active_device[0]
   else:
      print('Spotify Not Running - No Devices Found ')

   pass
